// Chia keo Euler

x1 + x2 + x3 + ... xn = s

nghiệm dương: C(s - 1, n - 1)
nghiệm không âm: C(s + n - 1, n - 1)
nghiệm có cận dưới(xi >= ai): C(s - (a1 + a2 + ... + an) + n - 1, n - 1)

x1 + x2 + x3 + ... + xn <= s:

nghiệm dương: C(s, n)
nghiệm không âm: C(s + n, n)

Bài toán phân hoạch:
x1 + x2 + x3 + ... + xn = s (ai <= xi <= bi)
đưa xi <= bi thành ngược của nó là bi + 1 <= xi, ta giải bài toán cận dưới:
int solve_mask(int msk){
	int sum = 0;
	fod(i,1,n){
		if(BIT(msk,i-1)) sum += b[i] + 1;
		else sum += a[i];
		if(sum > s + n - 1) return 0;
	}
	return COMB(s - sum + n - 1, n - 1);
}
res = 0
fod(msk,0,mask(n)-1){
	if(__builtin_popcount(msk) % 2 == 0) res += solve_mask(msk);
	else res -= solve_mask(msk);
}

Trường hợp đặc biệt:
x1 + x2 + x3 + ... + xn = s mà (L <= xi <= R)
Ta vẫn bao hàm loại trừ như thế nhưng có nhận xét chỉ cần xét số lượng của các tập hợp nên ta có thể tính nhanh sum của các tập(mask) k phần tử:
res = 0;
for (k : 0 -> n) {
	sum = k * (R + 1) + (n - k) * L;
	tmp = C(k, n) * C(n - 1, s - sum + (n - 1));
	if (k % 2 == 0) res += tmp; else res -= tmp;
}